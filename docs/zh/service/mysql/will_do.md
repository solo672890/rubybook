---
releaseTime: 2024/5/31
original: false
prev: false
next: false
sidebar: false
comment: false  
---

# mysql中的三种log
> 我认为,作为一个DBA,这些是必须要了解的知识

### 1️⃣ 图解

![explain](/document/will_do_demo1.png)


### 1️⃣ 执行update|insert sql 会发生什么事情?
1. 连接器：建立连接，验证权限
2. 查询缓存：检查是否有缓存（MySQL 8.0已移除）
3. 分析器：词法分析、语法分析
4. 优化器：生成执行计划，选择索引
5. 执行器：调用存储引擎接口执行
6. 存储引擎：
* 读操作：从内存或磁盘读取数据
* 写操作：
* 记录undo log（用于回滚）
* 更新内存数据
* 记录redo log（prepare状态）
* 记录binlog
* 提交事务，redo log改为commit状态


### 2️⃣ binlog (二进制日志)

> 它是二进制日志文件,以二进制的形式存储用于记录数据库的所有更改操作(如插入,更新,删除).
> 
> Binlog是MySQL事务日志的一部分,与Redo Log（重做日志）一起，确保数据库的一致性、持久性
> 
> 

::: details binlog作用
1. **数据恢复**：

Binlog记录了数据库的历史变更，通过重放Binlog中的事件，可以将数据库还原到特定的时间点。这对于恢复误删数据、应对错误的批量操作等情况非常有用。

2. **主从复制**

在主从复制中，主服务器将所有的更改记录到Binlog中，而从服务器通过读取主服务器的Binlog并执行相同的更改来保持数据同步。这实现了数据的复制和冗余，提高了系统的可用性和可靠性。

3. **点对点复制**：

类似于主从复制，但点对点复制允许多个服务器之间相互复制数据，而不仅限于主从关系。Binlog在这种情况下发挥着关键的作用，确保不同服务器之间的数据同步。

4. **数据库备份**：

Binlog也是数据库备份的一部分。通过备份Binlog，可以实现增量备份，只备份自上次完整备份以来发生的变更，从而减少备份的时间和存储成本。

5. **审计与监控**：

Binlog记录了数据库中的每个事务操作，包括操作的时间、执行者等信息。这对于审计数据库的访问记录、监控数据库的活动非常有帮助。
:::



::: details Binlog的重要性
1. **事务的一致性**：

Binlog记录了每个事务的开始和提交事件，通过重放Binlog，可以确保事务的一致性。即事务要么完全执行，要么完全不执行，维护了数据库的一致性。

2. **数据的持久性**：

在事务提交前，数据库引擎将事务的修改记录到Binlog中，确保数据的持久性。即使在事务提交后发生故障，可以通过重放Binlog来还原数据，保障数据库的持久性。

3. **数据同步与复制**：

Binlog在主从复制和点对点复制中发挥关键作用，确保不同服务器之间的数据同步。这对于分布式系统和数据冗余至关重要。

4. **故障恢复**：

在数据库崩溃或发生其他故障时，通过重放Binlog，可以将数据库还原到最后一次备份之后的状态，减少数据丢失。

:::

::: details binlog的类型
1. **Statement模式**：

在Statement模式下，MySQL将每个SQL语句作为一个事件记录到Binlog中。具体来说，每个更新操作（如INSERT、UPDATE、DELETE等）都以SQL语句的形式被记录。

**`优势`**：

* 易读性高： Binlog中记录的是SQL语句，便于人类阅读和理解。

* 节省空间： 因为记录的是SQL语句，所以通常比其他模式占用更少的存储空间。


**`适用场景`**：

* 基于SQL语句的复制： 当使用基于SQL语句的复制技术，或者要求Binlog具有高可读性时，可以选择Statement模式。

**`注意事项`**：

* 可能引发非确定性问题： 由于某些SQL语句的执行结果可能会受到环境和状态的影响，因此在一些特定场景下可能会引发非确定性问题。



2. **Row模式**：

在Row模式下，MySQL将每个被修改的行的内容作为一个事件记录到Binlog中。不再记录SQL语句，而是记录数据行的变更情况。

**`优势`**：

* 更精确： 记录了实际被修改的行，不受SQL语句的语法或环境影响，更为精确。

* 避免非确定性问题： 由于记录了行的具体变更情况，避免了某些非确定性问题。


**`适用场景`**：

* 要求更高精度的数据复制： 当要求更高的数据复制精度，或者在一些需要避免非确定性问题的场景中，可以选择Row模式。

**`注意事项`**：

* 占用更多存储空间： 由于记录了每个被修改的行，所以通常比Statement模式占用更多的存储空间。

3. **Mixed模式**：

Mixed模式是Statement模式和Row模式的结合，MySQL会根据具体的SQL语句来选择使用Statement模式或Row模式。大多数情况下，MySQL会选择Statement模式，但对于某些特殊的情况，会使用Row模式。

**`优势`**：

* 灵活性： 根据具体情况动态选择合适的模式，兼顾了Statement和Row模式的`优势`。。


**`适用场景`**：

* 在大多数情况下使用Statement模式，但对于一些特殊情况使用Row模式： Mixed模式在大多数情况下保持了Statement模式的高效性，但在需要更高精度的情况下可以动态切换到Row模式。

**`注意事项`**：

* 可能引发非确定性问题： 在Statement模式下可能存在的非确定性问题，在Mixed模式下仍然可能存在。

:::


`mysqlbinlog -v --start-datetime="2025-09-20 00:00:00" mysql-bin.000204 | grep -A 10 -B 10 "orders_detail_202506"`



### 3️⃣ redo log(重做日志)

> Redo log是InnDB存储引擎的特有的日志，记录的是物理级别的“页”修改操作，用于保证事务的持久性。
> 
> 我们知道MySQL数据存在磁盘中，每次读写数据需做磁盘I/O，并发场景下性能较差。为此 MySQL 引入缓存 Buffer Pool 做优化。其包含磁盘中部分数据页（Page）的映射，来缓解数据库的磁盘压力。
>
>当从数据库读取数据时，首先从缓存中读取，缓存中没有，则从磁盘读取后访日缓存。当向数据库写入数据时，先向缓存中写，此时缓存中的数据页数据会变更，该数据页叫脏页，Buffer Pool中修改完数据后会按照设定的策略再定期刷到磁盘中去，这个过程叫刷脏页。
>
>那么问题来了，如果Buffer Pool中修改的数据还没有及时的刷到磁盘，MySQL宕机重启，就会导致数据丢失，无法保证事务的持久性，怎么办？
>
>redo log解决了这个问题，就是说数据库在修改数据时，会把更新记录先写到redo log中，再去修改 Buffer Pool 中的数据，当提交事务时，调用fsync把 redo log 输入磁盘。至于缓存中更新的数据文件何时刷入磁盘，则由后台线程异步处理。
>
>注意：此时 redo log 的事务状态是prepare，还未真正提交成功，要等 binlog 日志写入磁盘完成后才会变为 commit，事务才算真正提交成功。



>MySQL 宕机重启，系统将自动检查 redo log，将修改还未写入磁盘的数据从 redo log 恢复到 MySql中。

**✅特点**：

* 循环写入，固定大小

* 记录的是：“在某个数据页上做了什么修改”

* 采用WAL（Write-Ahead Logging）技术

**✅应用场景**：

* 数据库崩溃恢复

* 实现事务的持久性

* 提高写入性能（随机写转为顺序写）

* 为什么使用WAL技术？


WAL（Write Ahead Logging）即预写式日志，其核心原则是：任何数据修改必须先写入日志，再写入磁盘。这样做的好处有：

* 减少磁盘I/O：将随机写转为顺序写，提高性能

* 保证数据安全：及时系统崩溃，也能通过redo log恢复

* 实现事务的持久性：确保已提交事务不会丢失

**✅写入方式**：

假设有这么一条SQL：`update user_table set name='张三' where id = '9'`



MySQL执行这条SQL语句时，应该是先把 id=9 的这条数据查出来，再将name字段改掉。这个逻辑没问题吧？

但实际上MySQL的基本存储结构是“页”（记录都存在页里面），所以MySQL是先把这条记录所在的页找到，然后把该页加载到内存中，再将对应的数据进行修改。

现在就可能存在一个问题：如果在内存中把数据修改了，还没来得及落到磁盘，而此时的数据库挂了怎么办？显然...这次的更改将会丢失。

如果每个请求都需要将数据立马落到磁盘之上，那速度会很慢，MySQL可能会扛不住。所以MySQL是怎么做的呢？

MySQL引入了redo log，内存写完之后，会写一份redo log，这份redo log记载着这次在某个页上做了什么修改（操作）。

写redo log也是需要写磁盘的，但它的好处就是顺序IO（顺序ID比随机IO速度更快）

所以，redo log存在的作用是：当我们在对数据进行修改时，写完内存后，但数据还没有真正写入到磁盘的时候，此时如果数据库异常，我们可以根据redo log来对数据进行恢复。因为redo log是顺序IO，写入的速度很快，并且redo log记录的是物理变化（xxx页做了xxx修改），文件的体积很小，恢复速度很快。

### 4️⃣ binlog与redo log的区别
>binlog和redo log都是用来“恢复”的，他们的区别是什么呢？
>

✅  **目的**：
* binlog：binlog主要用于恢复数据的修改操作，记录了对数据库进行的所有修改SQL语句，如：INSERT、UPDATE、DELETE、TRUNCATE等。它是用于数据备份、主从复制以及高可用性方案的关键组成部分。
* redo log：redo log用于数据库事务的持久性，记录了对数据库的逻辑变化。它主要用于确保在宕机或崩溃时，可以通过重做日志来重新执行已提交的事务，保证数据的一致性。

✅  **数据内容**：
* binglog：binlog以文本形式记录SQL语句或SQL语句的逻辑表示。它包含了对数据库的增删改操作的详细信息，可以用来重做这些操作。
* redo log：redo log是一个循环的、预分配的固定长度的二进制文件，记录了对数据库页的物理修改操作。它包含了物理上的页地址、修改前后的数据值等，用于重做被修改的页。

✅  **写入时机**：
* binlog：binlog是在事务提交之后才会被写入磁盘，它记录了已经完成的事务。
* redo log：redo log是在事务执行过程中被写入磁盘，这样可以确保事务在提交之前，对数据库的修改已经被记录下来。

✅  **大小和持久性**：
* binglog：binlog的大小是由配置参数binlog_max_size控制的，它可以被删除或轮换。它是非持久性的，即在数据库重启后会被清空，需要依靠备份来进行数据恢复。
* redo log：redo log的大小是固定的，当redo log被写满时，会被清空 并重用空间。它是持久性的，即在数据库重启后会被保留，可以确保数据的一致性。

✅ **总体而言**：

* binlog 主要用于记录已完成的操作，以实现数据备份、复制和恢复等功能。
* redo log 主要用于事务的持久性，以确保数据的一致性。它们在日志内容、写入时机和持久性等方面有所不用，但都是MySQL中重要的日志机制，为数据库的可靠性和可恢复性提供了支持。

### 5️⃣Undo Log（回滚日志）
> undo log是InnDB存储引擎特有的日志，记录事务发生前的数据状态，用于事务回滚和MVCC实现。
> 
> 在数据修改的时候，不仅记录了redo log，还记录了undo log，如果因为某些原因导致事务失败或回滚了，可以用undo log进行回滚
> 
>undo log主要存储的也是逻辑日志，比如我们要insert一条数据了，那undo log会记录的一条对应的delete日志。我们要update一条记录时，它会记录一条对应相反的update记录。
> 
> 因为undo log存储着修改之前的数据，相当于一个前版本，MVCC实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行了。

✅ **特点：**

* 逻辑日志，记录SQL执行前后的数据状态
* 存储在系统表空间的回滚段中
* 事务提交后不会立即删除，可能被MVCC使用

✅ **应用场景：**
* 事务回滚
* 实现MVCC（多版本并发控制）
* 提保证事务的原子性

✅ **作用**

* 事务回滚：让事务可以撤销
*  MVCC：多版本并发控制，实现非锁定读
* 一致性读：支持可重复读隔离级别








redo log 的写入方式？
　　redo log 采用大小固定，循环写入的方式，当写满后，会重新从头开始循环写，类似一个环状。这样设计的原因是 redo log 记录的是数据页上的修改，如果 Buffer Pool 中数据页已经刷到磁盘，这些记录就失效了，新日志会将这些失效的记录覆盖擦除。

注意：redo log 满了，在擦除之前，要确保这些要被擦除的记录都已经刷到磁盘中去了。在擦除旧记录释放新空间期间，不能再接收新的更新请求，此时 Mysql 性能会下降。因此高并发情况下，合理调整 redo log 的大小很重要。

crash-safe 能力是什么？
　　Innodb 引擎有 crash-safe 能力，即事务提交过程中的任何阶段，MySQL 宕机重启后都能保证事务的完整性，已提交的数据不会丢失。这种能力是通过 redo log 保证的，MySQL 宕机重启，系统将自动检查 redo log，将修改还未写入磁盘的数据从 redo log 恢复到 MySql中。

undo log 回滚日志（MySQL 存储引擎 InnoDB 的事务日志）
undo log 记录的是数据修改之前的状态，属于逻辑日志，起到回滚的作用，是保证事务原子性的关键。

举个例子：

假如更新 ID=1 记录的 name 字段， name 的原始数据为“张三”，先改 name 为“李四”事务执行 update user_table set name=李四 where ID=1 语句时，先在 undo log 中记录一条相反逻辑的 update user_table set name=张三 where id=1 的记录，这样当某些原因导致事务失败，就可以借助 undo log 将数据回滚到事务执行之前的状态。



那么问题来了：同一个事务的一条记录被多次修改，难道每次都要把数据修改前的状态写 undo log 吗？
不会，因为 undo log 只记录事务开始前数据的原始版本，当再次对这样数据修改时，产生的修改记录会写到redo log。undo log 负责回滚，redo log 负责前滚。

啥是回滚和前滚？
（1）回滚
未提交的事务，即事务未执行 commit。但事务内修改的脏页中，有一部分已刷盘。此时数据库宕机重启，需要回滚来将先前那部分已经刷盘的脏块从磁盘上撤销。

（2）前滚
未完全提交的事务，即事务已经执行 commit，但该事务内修改的脏页中只有一部分数据被刷盘，另一部分还在 buffer pool，此时数据库宕机重启，就要用前滚来将未来得及刷盘的数据从 redo log 中恢复出来并刷盘。



bin log 归档日志（数据库 Server 层二进制逻辑日志、和什么引擎无关）

bin log 记录了用户对数据库所有 sql 操作（不包含查询语句，因为这类操作对数据本身没有修改）。之所以可以称为归档日志，是因为它不会像 redo log 那样循环擦除之前的记录，而是会一直记录日志。一个 bin log 文件默认最大容量1G（可通过 max_binlog_size 参数修改），单个日志超过最大值则会新创建一个文件继续写。

注意：日志可能是基于事务来记录的，而事务不应该跨文件记录，如果 binlog 日志文件达到了最大值但刚好事务还没有提交，此时则不会创建新文件记录，而是继续增大日志。因此 max_binlog_size 的值和实际的 binlog 文件大小不一定相等。

经过上述介绍，binlog 主要用就是主从同步和数据库基于时间点的还原。


