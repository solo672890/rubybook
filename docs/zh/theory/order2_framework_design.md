---
releaseTime: 2025/8/4
original: true
prev: false
next: false
editLink: false
comment: true

---

# 分表后,客户端如何翻页查询?

> 做项目的时候遇到了这个问题,于是请教了同行,没几个人能说清楚的.
> 
> 估计是用的oracle这样的数据库吧,或者就没遇到需要分库分表的项目
> 
> 没办法,只能自己琢磨了

按照传统的分页查询办法,肯定不行.鬼知道客户在以前的某个月是否有下订单.也不可能每张月份表依次去查询.
经过调研`微信支付,淘宝,支付宝,拼多多`这4款大产品,以及网上一些相关资料,结合个人的分析,判定`不按照月份实现上拉刷新`这个功能挺麻烦的.

## 调研4大产品实现的订单记录下拉分页的表现效果
::: code-group
````[淘宝]
不按月份下拉翻页,每页10条记录,速度极快,即便翻页到10年前,响应速度非常快,

个人分析:
不清楚如何实现,
个人认为并非内存提前加载了所有的记录,有可能提前加载了下一页的数据.
个人猜测并非是分表中间件的功劳,因为这么搞,要吃的内存太多太多了.
有可能是仓(elasticSearch,Clickhouse等)的功劳+提前加载下一页,
也有可能做的是按user_id分库分表,百库百表等+魔改后的mysql.
````
````[pdd]
和淘宝一样
````
````[微信支付]
每页20条记录,按月分表,仅展示最近12个月的交易数据,
超过12个月后的数据,必须选择年月来查询

个人分析:
可能使用数仓工具,增加记录到mysql的月份表同时也增加到数仓里,
数仓(elasticSearch,Clickhouse等)保存最近一年的数据作为分析和查询,
历史数据则作为冷数据,必须按年月查询
````


````[支付包支付记录]
第一页展示了38条记录,第二页展示了20条记录,第三页展示了36条记录,第4页展示了20条记录,
按月分表

个人分析:
这里的38并非是一个固定的数字,是因为8月份刚好只有18条记录,
于是它从7月份取了20条记录补上,所以第一页有了38条数据.
但7月份超过40条记录,即便借给8月份20条,剩下的页足够分页,所以它第二页展示了20条记录
````
:::

## 调研结论
不止`淘宝,微信,支付宝,拼多多`.我还分析了一些其他大产品.发现他们的特征几乎一致

**1.订单可以无限制上拉翻页查询.不受时间限制**

**2.账变记录受时间限制,默认给出最近一年(或者半年)记录,超过期限则只能手动选择时间查询**

推测,账变记录更新更加频繁,且分库分表后,时间跨度太大不利于性能,于是给了一个时间限制.

也可以分析出,分库分表后,查询记录主要有2种方案

1.`有时间限制查询,只查询用户最近半年或一年的数据,超出期限的数据,用户手动选择时间查询`

2.`无时间限制查询,像淘宝一样,无限制上拉翻页`

我发现支付宝,微信都是将两种方案组合起使用.(订单无限制查询,其他记录有限制查询) **而且个人认为无限制上拉翻页成本非常高.**

那么中小项目,比如`币安,okx`等,他们所有的查询都是有时间限制查询.

所以我们在进行技术方案选型的时候,**无脑选择有时间限制查询即可**.除非运营方强烈要求.



## 无限制查询-按月份分表
我思来想去,还是补上这一部分内容.

如果有哪个天杀的甲方,非要你像淘宝订单,pdd订单一样无限制查询,那我就只有祭出这个方案了.

准备一个用户订单记录表,大概格式如下,每新增订单后,在对应的月份增加值


| id | user_id | ext                                                           |
 |:--:|:-------:|---------------------------------------------------------------|
| 1  |  1001   | `{"202508":5,"202507":24,"202503":39,"202502":1,"202408":11}` |
| 2  |  1002   | ...                                                           |
| 3  |  1003   | ...                                                           |
| 4  |  1004   | ...                                                           |


id=1,代表202508的时候,用户产生了5笔订单.

每页20条数据,我们可以计算出8月份+7月份有29条数,于是我们就有如下sql:

这里只是思路,具体查询的时候,where条件一定要带上时间游标
````
# 第一页,8月份全部取,7月份取15条
SELECT order_no, user_id FROM order_202508 WHERE user_id = 1001
UNION ALL
(
    SELECT order_no, user_id 
    FROM order_202507 
    WHERE user_id = 1001 
    ORDER BY id DESC  
    LIMIT 15
);

# 第2页,7月份已经被取了15条,所以取剩下的9条,然后再取3月份的11条
(
    SELECT order_no, user_id FROM order_202508 
    WHERE user_id = 1001 
    ORDER BY id DESC  LIMIT 15,9
)
UNION ALL
(
    SELECT order_no, user_id FROM order_202507 
    WHERE user_id = 1001 
    ORDER BY id DESC  
    LIMIT 0,11
);
# 第3页,以此类推
.........

# 极端情况
遇到用户每月只有一个订单,那岂不是要联查一堆表?
我的想法是,该次分页最多union all 6表,即给客户端返回6条数据.6条数据已经够客户端占满一个屏幕了.
````




**此办法会多查询1条sql,但是效率并不差.**


## 无限制查询-按user_id+每半年分表
事隔三月后,我突然又想到另一种方案.
以币安的订单量为参考,按user_id取模分成10表,即 order_userid1,order_userid2,order_userid3,order_userid4....


| id | user_id | ext                                                                     |
 |:--:|:-------:|-------------------------------------------------------------------------|
| 1  |  1001   | `{"202508_0":5,"202508_1":24,"202507_0":39,"202504_0":1,"202503_1":11}` |
| 2  |  1002   | ...                                                                     |
| 3  |  1003   | ...                                                                     |
| 4  |  1004   | ...                                                                     |

`_0`代表上半年,`_1`代表下半年,其余的思路按照 [追加-按月份分表](#追加-按月份分表) 进行.

这样设计的好处是,遇到极端情况,假设`某用户每月只有一个订单,那岂不是要联查一堆表?`,该方案可以减少联查表的数量


## 👉[限制查询](/service/mysql/ftable_query.html)

## 扩展
假如按月分表,数据量依然太大,导致读写性能低下,无法满足需求.

那么就要分库分表了.

把user_id取模后的结果,分成6库(根据项目情况自行决定),把订单根据user_id写入到不同的库中.












